<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>plum的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-27T07:54:00.955Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>plum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KVC探索与实践</title>
    <link href="http://yoursite.com/2017/05/23/KVC%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2017/05/23/KVC探索与实践/</id>
    <published>2017-05-23T09:41:56.000Z</published>
    <updated>2018-03-27T07:54:00.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KVC探索与实践"><a href="#KVC探索与实践" class="headerlink" title="KVC探索与实践"></a>KVC探索与实践</h1><blockquote><p>KVC通过实现非正式协议<code>NSKeyValueCoding</code>，来实现间接访问和设置对象属性的一种机制。</p></blockquote><p>使用KVC你可以做到以下一些操作：</p><p><br></p><h3 id="KVC基础（Key-Value-Coding-Fundamental）"><a href="#KVC基础（Key-Value-Coding-Fundamental）" class="headerlink" title="KVC基础（Key-Value Coding Fundamental）"></a>KVC基础（Key-Value Coding Fundamental）</h3><hr><h4 id="访问对象属性（Accessing-Object-Properties）"><a href="#访问对象属性（Accessing-Object-Properties）" class="headerlink" title="访问对象属性（Accessing Object Properties）"></a>访问对象属性（Accessing Object Properties）</h4><ul><li><p>获取值可以用以下方法:</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br></pre></td></tr></table></figure></li><li><p>设置值用以下方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">void</span>)setValuesForKeysWithDictionary:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)keyedValues;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><div class="tip"><br><strong>注意：</strong><br>    <div>1. 如果对象没有找到key，会抛出<code>NSUndefinedKeyException</code>,可以重写子类的<code>setValue:forUndefinedKey:</code>做一些自定义的逻辑判断。</div><br>    <div>2. 如果设置值是nil，会抛出 <code>NSInvalidArgumentException</code>，<code>可以重写setNilValueForKey:</code>做一些自定义的逻辑判断。</div><br></div><p> <br></p><h3 id="访问集合属性"><a href="#访问集合属性" class="headerlink" title="访问集合属性"></a>访问集合属性</h3><p>返回的值是集合，key对应的属性可以使任何值。涉及的方法如下：</p><p><strong>NSMutableArray</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutableArrayValueForKey: </span><br><span class="line">mutableArrayValueForKeyPath:</span><br></pre></td></tr></table></figure><p><strong>NSMutableSet</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutableSetValueForKey:</span><br><span class="line">mutableSetValueForKeyPath:</span><br></pre></td></tr></table></figure><p><strong>NSMutableOrderSet</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutableOrderedSetValueForKey:</span><br><span class="line">mutableOrderedSetValueForKeyPath:</span><br></pre></td></tr></table></figure><p><br></p><h3 id="使用集合操作符"><a href="#使用集合操作符" class="headerlink" title="使用集合操作符"></a>使用集合操作符</h3><p>使用集合操作符，可以对集合属性进行一下计算操作，比如计算平均值，总数等。使用的时候有两种方式</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Employee.h</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Department.h</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;Employee *&gt; *allEmployees;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.m</span></span><br><span class="line">Department *depart = [Department new];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line"><span class="built_in">NSNumber</span> *number = [depart.allEmployees valueForKeyPath:<span class="string">@"@sum.age"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line"><span class="built_in">NSNumber</span> *number = [depart valueForKeyPath:<span class="string">@"allEmployees.@sum.age"</span>];</span><br></pre></td></tr></table></figure><p>在KVC中使用操作符的格式如下(@count除外)：</p><p><img src="/2017/05/23/KVC探索与实践/1.jpg" alt=""></p><ul><li>左路径 (left key path):指向是集合类型的属性</li><li>操作符 (colletion operator): 以‘@’开始</li><li>右路径 (right key path):</li></ul><p><strong>操作符的种类：</strong></p><ol><li><strong>聚合操作符（Aggregation Operators）：</strong>返回单个值，比如<code>@count</code>、<code>@avg</code>、<code>@max</code>、<code>@min</code>、<code>@sum</code></li><li><strong>数组操作符（Array Operators）：</strong>返回值是数组，比如<code>@distinctUnionOfObjects</code>、<code>@unionOfObjects</code>，两者区别是@distinctUnionOfObjects没有重复值</li><li><p><strong>嵌入操作符（Nesting Operators）：</strong>返回值是NSArray或者NSSet,比如<code>@distinctUnionOfArrays</code>、<code>@unionOfArrays</code>、<code>@distinctUnionOfSets</code>。实例：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arrayOne = @[.....];</span><br><span class="line">NSArray *arrayOther = @[.....];</span><br><span class="line">NSArray *concactArray = @[arrayOne, arrayOther];</span><br><span class="line"></span><br><span class="line">NSArray *collectedDistinctPayees = [concactArray valueForKeyPath:@&quot;@distinctUnionOfArrays.payee&quot;];</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h3 id="非对象的数据"><a href="#非对象的数据" class="headerlink" title="非对象的数据"></a>非对象的数据</h3><p>基本的数据类型如<code>int</code>、<code>float</code>等，需要转换成<code>NSNumber</code>类型，<code>struct</code>需要转换成<code>NSValue</code>类型（针对Objective-C）</p><p><br></p><h3 id="键值验证（Validating-Properties）"><a href="#键值验证（Validating-Properties）" class="headerlink" title="键值验证（Validating Properties）"></a>键值验证（Validating Properties）</h3><p>KVC提供了可以检测设置的值的类型是否符合属性类型的要求的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br><span class="line">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;</span><br></pre></td></tr></table></figure><p>子类可以根据自己的校验逻辑重写这个方法。</p><p><br></p><h3 id="KVC设值和取值的流程"><a href="#KVC设值和取值的流程" class="headerlink" title="KVC设值和取值的流程"></a>KVC设值和取值的流程</h3><p><br></p><h5 id="通过Getter获取值"><a href="#通过Getter获取值" class="headerlink" title="通过Getter获取值"></a>通过Getter获取值</h5><p>当调用方法<code>valueForKey:</code>时，按照以下流程处理：</p><ol><li>按照<code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code>, <code>_&lt;key&gt;</code>的顺序寻找方法，如果寻找到了，跳转到步骤5，否则进行步骤2。</li><li>如果对象实现了<code>countOf&lt;Key&gt;</code>，同时实现了 <code>objectIn&lt;Key&gt;AtIndex:</code>，<code>&lt;key&gt;AtIndexes:</code> 其中的一个。对于方法 <code>get&lt;Key&gt;:range:</code>的是实现是<strong>可选</strong>的。如果实现了，那么就会生成一个集合代理对象（其实就是一个<code>NSMutatableArray</code>的子类<code>NSKeyValueMutableArray</code>），这个<code>集合代理对象</code>和<code>NSArray</code>的操作没什么区别。并返回这个集合代理对象。否则，进行步骤3。</li><li>如果对象同时实现了<code>countOf&lt;Key&gt;</code>, <code>enumeratorOf&lt;Key&gt;,</code> and <code>memberOf&lt;Key&gt;:</code>那么就会生成一个集合代理对象（其实就是一个<code>NSSet</code>的子类<code>NSKeyValueSet</code>），这个<code>集合代理对象</code>和<code>NSSet</code>的操作没什么区别。并返回这个集合代理对象。否则，进行步骤4。</li><li>查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, 或者<code>is&lt;Key&gt;</code>,然后直接获取值，进行步骤5。否则进行步骤6。</li><li>如果是<code>对象类型</code>，直接返回，如果是<code>int</code>、<code>struct</code>等数据类型封装成<code>NSNumber</code>或者<code>NSValue</code>。</li><li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li></ol><p><br></p><h5 id="通过Setter设值"><a href="#通过Setter设值" class="headerlink" title="通过Setter设值"></a>通过Setter设值</h5><p>当调用方法<code>setValue:forKey:</code>时，按照以下流程处理：</p><ol><li>安装顺序寻找方法 <code>set&lt;Key&gt;:</code> ， <code>_set&lt;Key&gt;</code>，如果找到了把输入的值当做参数传入其中。</li><li>查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, 或者<code>is&lt;Key&gt;</code>,然后直接获赋值。</li><li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li></ol><p><br></p><h5 id="返回可变数组-Mutable-Ordered-Sets"><a href="#返回可变数组-Mutable-Ordered-Sets" class="headerlink" title="返回可变数组/Mutable Ordered Sets"></a>返回可变数组/Mutable Ordered Sets</h5><p>当调用方法<code>mutableArrayValueForKey:</code>或者<code>mutableOrderedSetValueForKey:</code>时，按照以下流程处理：</p><ol><li><p>判断是否实现以下方法</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两个方法和 NSMutableArray/NSMutableOrderedSet 的方法 insertObject:atIndex: 和 removeObjectAtIndex: 对应</span></span><br><span class="line">insertObject:<span class="keyword">in</span>&lt;Key&gt;AtIndex:</span><br><span class="line">removeObjectFrom&lt;Key&gt;AtIndex:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个方法和 NSMutableArray/NSMutableOrderedSet 的方法 insertObjects:atIndexes: 和 removeObjectsAtIndexes: 对应</span></span><br><span class="line">insert&lt;Key&gt;:atIndexes: </span><br><span class="line">remove&lt;Key&gt;AtIndexes:</span><br></pre></td></tr></table></figure><p>   中的一个<strong>插入</strong>和<strong>移除</strong>方法。如果实现了，那么就返回一个代理对象。否则进行步骤2。而对于方法</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">replaceObjectIn&lt;Key&gt;AtIndex:withObject: </span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</span><br></pre></td></tr></table></figure><p> 可以增强效果。</p></li><li>寻找 <code>set&lt;Key&gt;:</code>方法。</li><li>如果<code>array / mtuableOrderSet</code>的方法和 <code>set&lt;Key&gt;:</code>都没有寻找到。查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>&lt;key&gt;</code>,如果找到了，会生成一个代理对象，这个对象会把NSMutableArray的方法发送给这个实例变量。</li><li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li></ol><p><br></p><h5 id="返回mutableSet"><a href="#返回mutableSet" class="headerlink" title="返回mutableSet"></a>返回mutableSet</h5><p>当调用方法<code>mutableSetValueForKey:</code>时，按照以下流程处理：</p><ol><li><p>判断是否实现以下方法</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两个方法和  NSMutableSet 的方法  addObject: 和  removeObject: 对应</span></span><br><span class="line">add&lt;Key&gt;Object:</span><br><span class="line">remove&lt;Key&gt;Object:</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这两个方法和  NSMutableSet 的方法  unionSet: 和  minusSet: 对应</span></span><br><span class="line">add&lt;Key&gt;:</span><br><span class="line">remove&lt;Key&gt;:</span><br></pre></td></tr></table></figure><p> 中的一个<strong>添加</strong>和<strong>移除</strong>方法。如果实现了，那么就返回一个代理对象。否则进行步骤2。而对于方法</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intersect&lt;Key&gt;:</span><br><span class="line">set&lt;Key&gt;:</span><br></pre></td></tr></table></figure><p> 可以增强效果。</p></li><li><p>如果响应 <code>mutableSetValueForKey:</code>的对象是一个<code>managed object</code>（像<code>CoreData的Managed Object</code>）,查询将停止。</p></li><li>寻找 <code>set&lt;Key&gt;:</code>方法。</li><li>如果<code>array / mtuableOrderSet</code>的方法和 <code>set&lt;Key&gt;:</code>都没有寻找到。查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>&lt;key&gt;</code>,如果找到了，会生成一个代理对象，这个对象会把NSMutableArray的方法发送给这个实例变量。</li><li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li></ol><p><br><br>参考资料：</p><ul><li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA" target="_blank" rel="noopener">Key-Value Coding Programming Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;KVC探索与实践&quot;&gt;&lt;a href=&quot;#KVC探索与实践&quot; class=&quot;headerlink&quot; title=&quot;KVC探索与实践&quot;&gt;&lt;/a&gt;KVC探索与实践&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;KVC通过实现非正式协议&lt;code&gt;NSKeyValueCodin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KVO探索与实践</title>
    <link href="http://yoursite.com/2017/04/12/KVO%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2017/04/12/KVO探索与实践/</id>
    <published>2017-04-12T09:41:56.000Z</published>
    <updated>2018-03-27T07:54:00.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KVO探索与实践"><a href="#KVO探索与实践" class="headerlink" title="KVO探索与实践"></a>KVO探索与实践</h1><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context</span><br></pre></td></tr></table></figure><p>这里有两个需要掌握的知识点：</p><h4 id="1-options"><a href="#1-options" class="headerlink" title="1. options"></a><code>1. options</code></h4><ul><li>NSKeyValueObservingOptionNew：最新的<code>value</code></li><li>NSKeyValueObservingOptionOld：之前的<code>value</code></li><li>NSKeyValueObservingOptionInitial: 在注册成观察者之前就会向观察者发送一条同时</li><li>NSKeyValueObservingOptionPrior: 在调用<br><code>- (void)willChangeValueForKey:(NSString *)key</code>之前被调用</li></ul><h4 id="2-context"><a href="#2-context" class="headerlink" title="2. context"></a><code>2. context</code></h4><p>这个参数可以给观察者发送一些数据，多用于区分<code>keyPath</code>，当然是用响应通知的KeyPath也能区分。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ChangeNameContenxt = &amp;ChangeNameContenxt;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="comment">//way one</span></span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"name"</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//or</span></span><br><span class="line">    <span class="comment">//way two</span></span><br><span class="line">    <span class="keyword">if</span> (context == ChangeNameContenxt) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="实践探索"><a href="#实践探索" class="headerlink" title="实践探索"></a>实践探索</h3><h4 id="To-One"><a href="#To-One" class="headerlink" title="To-One"></a>To-One</h4><p><strong>1. 自动发送（Automatic Change Notification）</strong></p><p>这里就是一般使用的KVO的场景，省略。<br><br><br><strong>2. 手动发送（ Manual Notification）</strong><br>首先要重写方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key</span><br></pre></td></tr></table></figure><p>根据key判断哪些属性需要手动触发KVO,它还可以用另外一个简单的方法代替：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversOf*Key*</span><br></pre></td></tr></table></figure><p>此处的key就是需要手动触发KVO的属性。另外，还需要在setter里面手动触发消息，在赋值之前调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><p>在赋值完成后调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="To-Many"><a href="#To-Many" class="headerlink" title="To-Many"></a>To-Many</h4><p>了解这个知识点之前，需要知道<code>NSKeyValueChange</code>:</p><ul><li><code>NSKeyValueChangeSetting</code>: 赋值通知（默认）</li><li><code>NSKeyValueChangeInsertion</code>: 插入通知</li><li><code>NSKeyValueChangeRemoval</code>: 删除通知</li><li><code>NSKeyValueChangeReplacement</code>: 替换通知</li></ul><p>当需要观察的属性是一个<code>Collection</code>的时候，单纯的观察属性是不在<code>Collection</code>进行<code>添加</code>、<code>删除</code>、<code>替换</code>操作是能获取到通知。所以需手动触发KVO.<br>首先要重写方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">或者</span><br><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversOf*Key*</span><br></pre></td></tr></table></figure><p>然后要在改变之前调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChange:(<span class="built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><p>改变之后调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didChange:(<span class="built_in">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes forKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><p>这两个接口需要传入一个<code>NSIndexSet</code>对象，来确定进行<code>添加</code>、<code>删除</code>、<code>替换</code>操作的位置。<br><br></p><h4 id="相互影响的属性"><a href="#相互影响的属性" class="headerlink" title="相互影响的属性"></a>相互影响的属性</h4><p>有些情况下，除了改变被观察的属性发生变化要发通知之外，修改某一属性的值也可能影响到被观察的属性，也要触发KVO通知。<br>对于这种情况，需要重写：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line"> 或者</span><br><span class="line"> + (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffecting*Key*</span><br></pre></td></tr></table></figure><p>把相关的属性通过<code>NSSet</code>返回。除此之外，还需要重写被观察属性的<code>getter</code>方法，表明被观察属性和影响属性的关系<strong>（如果不写：那么接收KVO的方法返回的值就不会和影响属性有关系）</strong>。<br>例如，姓名由姓和名组成，那么改变姓或者名，那么这个姓名就会发生变化。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *fullName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"firstName"</span>, <span class="string">@"lastName"</span>, <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)fullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@-%@"</span>, _firstName, _lastName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在观察的接受方法中：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context</span><br></pre></td></tr></table></figure><p>就会接收到<code>fullName</code>改变的通知</p><p><br></p><h4 id="深层嵌套属性"><a href="#深层嵌套属性" class="headerlink" title="深层嵌套属性"></a>深层嵌套属性</h4><blockquote><p>假象一种场景：一个部门有一些工作者，当他们的工资发生变化是，统计部门的总工资也要变化。解决这一问题有两种方法；</p></blockquote><p><strong><em>解决方法一：</em></strong> 先分析，这里有两个模型 <code>Department</code>、<code>Employee</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Department.h</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;Employee *&gt; *employees;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> totalSalary;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Employee.h</span><br><span class="line">@property (nonatomic, assign) NSInteger salary;</span><br></pre></td></tr></table></figure><p>在初始化<code>Department</code>时，把<code>Department</code>注册成为<code>Employee</code>的观察者。<br>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Department.m (init)</span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//array</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Employee *employe = [Employee new];</span><br><span class="line">            employe.salary = i;</span><br><span class="line">            [employe addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"salary"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">            [array addObject:employe];</span><br><span class="line">        &#125;</span><br><span class="line">        _employees = [array <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在接收KVO通知方法里面：</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    [<span class="keyword">self</span> setTotalSalary:[[<span class="keyword">self</span> valueForKeyPath:<span class="string">@"employees.@sum.salary"</span>] integerValue]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样观察<code>Department</code>的<code>totalSalary</code>属性就可以观察到变化了。</p><p><strong><em>解决方法二：</em></strong>使用<code>CoreData</code>来实现。<br><br></p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>正如苹果官方文档里面的描述：</p><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p><p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p><p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p><p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p></blockquote><p>当某一属性被观察时，会生成一个中间类<strong>（NSKVONotifying_原类名）</strong>，改中间类会做一下处理</p><ul><li>重写<code>setter</code>，手动发送KVO通知。</li><li>重写<code>class</code>方法，隐藏真实类名，不过可以用<code>object_getClass()</code>获取。</li><li>添加方法<code>- (BOOL)_isKVOA</code>判断被动态生成KVO子类</li></ul><p><br></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><div class="tip"><br>    <div>1. 在被观察对象释放的时候需要移除KVO</div><br>    <div>2. 一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。</div><br></div><p><br></p><h6 id="资料参考："><a href="#资料参考：" class="headerlink" title="资料参考："></a>资料参考：</h6><ul><li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA" target="_blank" rel="noopener">Key-Value Observing Programming Guide</a></li><li><a href="http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/" target="_blank" rel="noopener">objc kvo简单探索</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;KVO探索与实践&quot;&gt;&lt;a href=&quot;#KVO探索与实践&quot; class=&quot;headerlink&quot; title=&quot;KVO探索与实践&quot;&gt;&lt;/a&gt;KVO探索与实践&lt;/h1&gt;&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字节序</title>
    <link href="http://yoursite.com/2017/03/22/%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/03/22/字节序/</id>
    <published>2017-03-22T09:41:56.000Z</published>
    <updated>2018-03-27T07:54:00.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h1><blockquote><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为<code>int</code>的变量<code>x</code>地址为<code>0x100</code>，那么其对应地址表达式<code>&amp;x</code>的值为<code>0x100</code>。且<code>x</code>的四个字节将被存储在存储器的<code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code>位置。<br>而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。<br>例如假设上述变量<code>x</code>类型为<code>int</code>，位于地址<code>0x100</code>处，它的十六进制为<code>0x01234567</code>，地址范围为<code>0x100~0x103</code>字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：<code>0x100: 01, 0x101: 23,..</code>。而小端法将是：<code>0x100: 67, 0x101: 45,..</code></p></blockquote><p>###网络字节序<br>网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。<br>Berkeley套接字定义了一组转换函数，用于<code>16bit</code>和<code>32bit</code>整数在网络序和本机字节序之间的转换。<code>htonl</code>，<code>htons</code>用于本机序转换到网络序；<code>ntohl</code>，<code>ntohs</code>用于网络序转换到本机序</p><p>最近项目涉及到H264的编解码，传输的方式是采用socket其中解码的时候需要根据服务器传输的数据流的头部获取一些数据，比如屏幕宽、高、屏幕分辨率等，简单的说结构如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Header &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> width;     <span class="comment">//宽</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> height;    <span class="comment">//高</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> pixel;         <span class="comment">//分辨率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里会出现什么问题呢？</p><ol><li>网络字节序是采用<code>大端序</code>，简单的说就是把数据的高位存在低地址下。</li><li>数据流的的格式如下<code>&lt;Header&gt;&lt;NALU&gt;</code>,所以我第一是要知道<code>Header</code>的长度，如果直接用<code>sizeof(Header)</code>获取产长度的话，获取的长度可能以为平台的不同而有出入，根本原因是因为<code>内存对齐</code>规则，这个我会在下一篇文章分享。</li></ol><p>###大端序和小端序（big-endian vs little-endian）<br>其实大端序可以理解从左往右读取，小端序是从右往左读取。为了解释方便我们就用0x0A0B0C0D作为对象并且数据大小以8bit为单位。</p><ul><li><strong><em>大端序 (big-endian)</em></strong><br><br>地址增长方向 → <br></li></ul><table><thead><tr><th>…</th><th>0A</th><th>0B</th><th>0C</th><th>0D</th><th>…</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>示例中，最高位字节<code>0x0A</code> 存储在最低的内存地址处。下一个字节<code>0x0B</code>存在后面的地址处。正类似于十六进制字节<code>从左到右</code>的阅读顺序</p><ul><li><strong><em>小端序 (little-endian)</em></strong> <br><br>地址增长方向 → <br></li></ul><table><thead><tr><th>…</th><th>0D</th><th>0C</th><th>0B</th><th>0A</th><th>…</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>最低位字节是<code>0x0D</code> 存储在最低的内存地址处。后面字节依次存在后面的地址处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字节序&quot;&gt;&lt;a href=&quot;#字节序&quot; class=&quot;headerlink&quot; title=&quot;字节序&quot;&gt;&lt;/a&gt;字节序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为&lt;code&gt;int&lt;/c
      
    
    </summary>
    
    
  </entry>
  
</feed>
